* Вернуться к главе "Микроконтроллер и ядро ARM Cortex-M3" после прочтения книги
* 
![[Снимок экрана 2025-04-04 123713.png]]
![[Снимок экрана 2025-04-04 123728.png]]
![[Снимок экрана 2025-04-04 123745.png]]
##### Классификация микроконтроллеров
Устоявшейся классификации не существует, однако все МК можно разделить по трем классам параметров: набору инструкций, разрядности (размер обрабатываемых данных - 2 в n-ой степени) и назначению.
**Классификация по набору инструкций**
- CISC (Complex Instruction Set Computing) - больше присуща процессорам, из микроконтроллеров её унаследовало ядро 8051
- RISC (Reduced Instruction Set Computing) - используется в большинстве микроконтроллеров
**Классификация МК по разрядности шины**
- 8-битные (Atmel, ATtiny/ATmega/ATXmega, STM8 и др.)
- 16-битныке (TI MSP430, Microchip PIC24 и др.)
- 32-битные (STM32, NXP LPC2xxx и др.)
**Классификация по назначению**
- Универсальные - данный вид МК появился раньше всех, они содержат разнообразную периферию
- Специализированные - вид МК, который заточен под определенную задачу, например МР3-декодер или различного рода DSP
##### Классификация Cortex
Cortex разделяется на три семейства:
- Cortex-A - ядра общего назначения, такие устанавливаются, например, в смартфоны; 
- Cortex-M — для встраиваемых систем⁵;
- Cortex-R — для приложений реального времени.
##### Прерывания
Программа останавливается (при этом её текущее состояние сохраняется на стек), и начинает работать другой участок кода, называемый обработчиком (handler) прерывания. По завершении выполнения обработчика программа возвращается на то место, где была прервана, и продолжает свою работу.
![[Снимок экрана 2025-04-04 103242.png]]
Каждое прерывание вызывается событием, но не каждое событие вызывает прерывание.
Прерывания можно разделить на три типа:
- Асинхронные (внешние) - такие события, которые происходят от внешних источников, таких как периферийные устройства, а значит, могут произойти в произвольный момент времени. Они создают запрос на прерывание (Interrupt ReQuest, IRQ)
- Синхронные (внутренние) - события непосредственно в ядре, вызванные нарушением условий при исполнении кода: делением на ноль, переполнением стека, обращением к недопустимым адресам памяти и т.д.
- Программные (частный случай внутреннего прерывания) - прерывание может быть вызвано непосредственно в коде исполняемой программы.
---
Все имена существующих векторов прерываний описаны в файле ``startup_<mcu>.s
Каждому прерыванию ставят в соответствие число - так называемый номер прерывания (position). Чтобы связать адрес обработчика с номером, используется таблица векторов прерываний (vector table).
Таблица прерываний в микроконтроллерах с ядром ARM является векторной. Каждый элемент в ней - это 32-битный адрес, указывающий на определенный обработчик.
Первые 15 элементов строго закреплен стандартом ядра, все последующие прерывания называются вендор-зависимыми.
![[Снимок экрана 2025-04-04 105450.png]]
В таблице есть колонка "Приоритет". Чем меньше число, описывающее его, тем более важным является прерывание. Первые три прерывания описываются отрицательным числом. Приоритеты всех остальных прерываний можно настраивать.
Для чего используются приоритеты. Буква N в названии модуля NVIC происходит от слова nested, т.е. "вложенный". Если во время работы обработчика некоторого прерывания произойдет другое, приоритет которого больше, чем того, что обрабатывается сейчас, то произойдет то же самое, что и с основной программой.
___
- SysTick_Handler. 24-битный системный таймер SysTick. Таймеры предназначены в основном для подсчета, например тактов.
- SVC_Handler. Данный обработчик прерывания выполняется после вызова svc (Super Vision Call), которая запрашивает привилегированный режим работы у ядра. Используется для запуска планировщика задач.
- PendSV_Handler. Прерывание (Pendable SerVice) используется операционной системой для переключения задач.
##### Регистры
Регистры - специализированный тип памяти, который бывает двух типов: регистры ядра и регистры периферии.
В Cortex-M3 насчитывается 21 регистр ядра. Первые 13 называются регистрами общего назначения.
![[Снимок экрана 2025-04-04 113709.png]]
Регистры общего назначения - это ячейки памяти, расположенные непосредственно в ядре и предназначенные для выполнения инструкций.
Регистр R13 отводится под указатель стека (stack pointer). На самом деле их два, но в любой момент времени доступен только один из них.
Регистр связи (link register) R14 используется для запоминания адреса возврата при вызове подпрограммы (функции), что позволяет вернуться к выполнению прерванного кода.
Регистр R15, счетчик команд (program counter), отводится для хранения адреса текущей команды.
___
Все последующие регистры именуются специальными:
**PSR** (program status register) состоит из трёх частей:
- ARSR - регистр, хранящий состояния приложения при помощи флагов:
1. N (negative flag) - отрицательный результат операции
2. Z (zero flag) - нулевой результат операции
3. C (carry flag) - флаг переноса/займа
4. V (overflow flag) - флаг переполнения
5. Q (saturation flag) - флаг насыщения
- IPSR - регистр хранящий номер обрабатываемого прерывания
- EPSR - регистр состояния выполнения
![[Снимок экрана 2025-04-04 121822.png]]
**PRIMASK** (priority mask) использует один бит, который по умолчанию установлен в 0, запрещая все прерывания с настраиваемым приоритетом (т.е. все прерывания, кроме системных). Если записать туда 1, прерывания разрешаются.
**FAULTMASK** управляет маскируемыми (переключаемыми) прерываниями, глобально разрешая или запрещая их, кроме NMI (npn-maskable interrupt). По умолчанию нулевой бит сброшен в ноль, т.е. такие прерывания запрещены.
**BASEPRI** использует первые 8 бит и применяется для запрета прерываний, приоритет которых меньше или равен записанному в него значению. Чем меньше значение, тем выше уровень приоритета. Всего получается 128 уровней.
**CONTROL** отвечает за режим работы процессора и используемого стека
Режимов у ядра может быть два: привилегированный и непривилегированный. Нулевой бит регистра nPRIV, задает режим, а первый, SPSEL - используемый стек. В привилегированном режиме доступны все области памяти и инструкции.
##### Представление информации
![[Снимок экрана 2025-04-04 131448.png]]
##### Модульность
Модуль - законченный, автономный (в идеале) кусок программного кода, реализующий некоторую функциональность и предоставляющий интерфейс к ней.
##### Компилятор GCC
Компиляция файла и получение исполняемого файла:
```
gcc main.c
``` 
Для изменения названия исполняемого файла. Необходимо использовать ключ -o:
```
gcc main.c -o main
```
По умолчанию GCC использует стандарт c89 (с некоторыми расширениями). Для того чтобы указать версию стандарта явно, нужно добавить флаг -std=.
```
gcc -std=c99 main.c -o main
```
Компиляция программа выглядит следующим образом:
![[Снимок экрана 2025-04-07 164956.png]]
Для указания полного пути к файлу, который расположен в другой директории можно использовать ключ -I
```
gcc -std=c99 -Iconfig main.c ds18b20.c lcd.c -o main
```
##### Утилита make
Файл Makefile имеет следующую структуру:
![[Снимок экрана 2025-04-07 175515.png]]
```
run : ./main 
main : main.o ds18b20.o lcd.o
	gcc main.o ds18b20.o lcd.o-o main
	
main.o : main.c config/device.h ds18b20.c ds18b20.h lcd.c lcd.h
	gcc-std=c99-Iconfig-c main.c
ds18b20.o : ds18b20.c ds18b20.h
	gcc-std=c99-c ds18b20.c
lcd.o : lcd.c lcd.h
	gcc-std=c99-c lcd.c
```
##### Области видимости
Если создаются переменные с одинаковыми именами и типами данных, то новая переменная перекрывает старую.
```C
int main(void)
{
	int a=0;
	int i=0; //i(main)
	for(inti=0;i <5;i++){ //i(for) 
		a+=i; //i(for)
	} //a=(0+1+2+3+4)=10
	//i(for)
	for(i=0;i <5;i++){ //i(main)
		a+=i;
	} //a=(10+0+1+2+3+4)=20
	i+=a; //i(main)=5+(20)=25
	return0;
}
```
Ключевое слово **static** объявляет переменную, которая имеет статическую продолжительность хранения. А именно существует в течение всего времени выполнения программы.
Ключевое слово **extern** объявляет переменную, которая размещается в статической области памяти. И позволяет обращаться к данной переменной из других файлов.
##### Динамическая продолжительность хранения
В отличие от автоматических и статических переменных, память под которые выделяется во время компиляции, динамические получают ресурсы во время выполнения программы.
При этом память не будет освобождена до тех пор, пока программист явно не укажет этого или пока программа не завершит свою программу.
**Стек** - один из типов структур данных, описываемый фразой "Первый пришел, последний ушёл". 
На первом этапе в стеке хранится все необходимые для работы с функцией main() адреса и переменные. Далее в стек складываются параметры функции и указатели на области памяти, где хранится наша функция. По завершении работы функции вершина стека опускается (физического стирания не происходит), т.е. указатель спускается к main().
![[Снимок экрана 2025-04-08 120420.png]]
**Куча** - область памяти, предназначенная для динамических объектов, порождаемых во время выполнения программы.
## Язык С
Препроцессор - программа, которая подготавливает исходный код к компиляции, совершая подстановки и включения файлов, а также вводит микроопределения. Основные директивы препроцессора начинаются со знака # 
##### Директива include
Данная директива позволяет включать содержимое файлов на место строчки, где она написана. 
Если этот файл располагается в стандартной директории (имеется в системных путях операционной системы), то его имя, как правило, заключается в угловые скобки, если же файл находится в текущем каталоге, то используются кавычки.
```C
.#include <stdio.h> // system path directory
.#include "ds18b20.h" // current directory 
.#include "config/device.h" // nested folder
```
##### Директива define
Хороший код от плохого отличается в том числе тем, что в нем отсутствуют непонятные константы в середине исходного кода. 
```C
.#define [ИДЕНТИФИКАТОР] [ЗАМЕНА]
```
Данную директиву можно использовать для создания макросов или наоборот вставлять туда участки кода
```C
//circlearea
.#define S(x) (3.1415926f*x*x)
//enableportAclocking
.#defineRCC_PORT_A_ON (RCC->APB2ENR|=RCC_APB2ENR_IOPBEN)
//...
intmain(void){
	RCC_PORT_A_ON();
	inta=S(10);
	return0;
}
```
##### Условные директивы
Есть возможность включения определенной директивы при помощи условного оператора.
```C
.#ifdefPCB_REV_A 
.#defineBUTTON_PORTGPIOA 
.#else
.#defineBUTTON_PORTGPIOB
.#endif
```
Если PCCB_REV_A была где-то определена ранее, то создается макрос BUTTON_PORT со значением GPIOA, в противном случае GPIOB.
#### Модификаторы
Модификаторы можно разделить на четыре типа: модификаторы времени хранения, класса хранилища, размера и знаковости.
##### Модификаторы времени хранения
По умолчанию все переменные являются автоматическими, тоесть их область видимости ограничена блоком, в котором они были объявлены.
Следующий модификатор: extern. Он позволяет создать внешнее связывание переменной. Тоесть мы берем переменную из одного файла и используем её в другом.
##### Модификаторы класса хранилища
Если переменная должна менять своё значение асинхронно своей программе, то необходимо использовать модификатор volatile.
##### Ключевые слова break и continue
При необходимости преждевременного завершения цикла, можно использовать ключевое слово break. 
Аналогичным образом работает ключевое слово continue, но оно не завершает цикл полностью, а позволяет перейти к следующей итерации.
##### Модификаторы функции
В стандарте с99 появился модификатор **inline**. Данный модификатор работает по примеру define, тоесть он подставляет вместо вызова функции саму функцию.
Модификатор **static** делает функцию недоступной из другого модуля.
Соответственно модификатор **extern** делает функцию доступной из других файлов, без необходимости объявления её в заголовочном файле.
##### Обобщенные макросы
В стандарте с11 появилось новое ключевое слово **__Generic** которое позволяет создавать "обобщенные" макросы:
```C
.#define get_type(var) \
			_Generic((var), \
			int: "int", \
			char: "char", \
			double: "double" \
			//...
```
### Библиотеки МК
![[Снимок экрана 2025-04-11 135809.png]]
##### Библиотека CMSIS
Библиотека CMSIS включает в себя следующие компоненты:
- CMSIS-CORE: API для ядра Cortex-M и периферии.
- CMSIS-Driver: определяет основные драйверы интерфейсов периферии.
- CMSIS-DSP: коллекция из более чем 60 функций для различных типов данных (относятся к обработке сигналов)
- CMSIS-RTOS API: общий API для систем реального времени.
- CMSIS-DAP: стандартизированное программное обеспечение для отладчика.
Структура CMSIS-CORE:
![[Снимок экрана 2025-04-11 140639.png]]
##### Организация структур
При объявлении переменных в структуре необходимо их объявлять в порядке возрастания их размера. Сначала 8-битные, затем 16-, 32- и 64-битные переменные и только после этого объявлять массивы.
Также есть вариант выровнять данные при помощи атрибута packed:
```C
//...
} __attribute__((packed)) [название объекта структуры]; 
//...
```
Чтобы быть уверенным, что структура занимает четное количество полуслов/слов в памяти можно использовать атрибут aligned(x), где х - степень двойки.
```C
typedefenum{
	uint8_tname[10];
}__attribute__((packed, aligned(2)))SETTINGS_t;
//sizeof(SETTINGS_t)== 10
typedefenum{
	uint8_tname[10];
}__attribute__((packed, aligned(4)))SETTINGS_t;
//sizeof(SETTINGS_t)== 12
```

___
 ### Тестирование
 Стоит прочитать: Test Driven Development for Embedded C (Pragmatic Programmers) https://www.amazon.com/Driven-Development-Embedded-Pragmatic-Programmers-ebook/dp/B01D3TWF5M
 "Заглушки" - mock-объекты - временные сущности (объекты или функции), симулирующие реальное поведение.
Для встраиваемых систем очень хорошо подходят фреймворки: [Unity](https://www.throwtheswitch.org/unity) и [CPPUnit](https://freedesktop.org/wiki/Software/cppunit/)
___
### Архитектура программного обеспечения

##### DOS-стиль
DOS - однозначная операционная система. В любой момент времени в ней могла исполняться только одна программа, а для переключения между приложениями приходилось завершать работу одной и только потом запускать другую.
![[Снимок экрана 2025-04-15 082012.png]]
##### Windows-стиль
Программы в Windows могут исполняться "одновременно". Это некоторая условность, поскольку в один момент времени исполняется только одна программа.
![[Снимок экрана 2025-04-15 082643.png]]
##### ПО встраиваемых систем
Во встраиваемых системах ни одна из вышеописанных моделей не находит применения в чистом виде. Можно выделить три типа:
1. Линейная программа, основанная на главном цикле (main loop), который ещё называют суперциклом (super loop);
2. Программа с главным циклом и прерываниями;
3. Приложение с операционной системой реального времени (ОСРВ).
![[Снимок экрана 2025-04-15 083638.png]]
В зависимости от сложности проекта и предъявляемых требований применение находит каждый из подходов.
![[Снимок экрана 2025-04-15 084034.png]]
##### Линейная программа на главном цикле
Программа на главном цикле проста в реализации и хорошо подходит в тех случаях, когда функциональность устройства сильно ограничена. Допустим, устройство собирает показания с датчиков и отправляет их на некоторое центральное устройство, которое, в свою очередь, принимает решение.
##### Главный цикл и прерывания
Вотличиеотпредыдущегоподхода,гдекодвыполняетсялинейно,этотметодподразумевает асинхронное выполнение участков кода вне главного цикла.
Сами прерывания бывают внутренними и внешними по отношению к ядру. В нашем случае нажатие кнопки — это внешнее прерывание. В STM32 за них отвечает модуль EXTI. Для обработки исключительного события (прерывания) необходимо задать имя функции, называемой обработчиком. Ее название фиксировано для каждого источника, и найти его можно в таблице векторов прерываний, указанных в startup-файле.
**Прерывания должны служить причиной изменения состояния устройства, а не выполнять работу основной программы.**
### Операционная система реального времени (ОСРВ)
Операционная система реального времени — это не про высокую производительность, а про гарантию времени отклика.
ОС настольных компьютеров позволяют вам практически полностью абстрагироваться от аппаратной платформы. С ОСРВ это не так—она так же предоставляет разработчику интерфейс распределения ресурсов, но в виде набора функций — библиотеки, которая подключается к проекту с прошивкой и компилируется вместе с ней.
![[Снимок экрана 2025-04-15 115318.png]]
Минимальная реализация ОСРВ состоит из тех же частей, что и bare-metal прошивки. Главный цикл заменяется на "задачу" с низшим приоритетом и вместе с блоком прерываний он образует ядро. Помимо них, к программе добавляются и другие задачи, в которых задается логика работы устройства.
![[Снимок экрана 2025-04-15 115551.png]]
##### Задачи
Задача - блок программного кода, ответственный за обработку событий. Любая задача может быть в одном из двух состояний: выполняющаяся и не выполняющаяся (разделяется на другие подсостояния).
- **Выполняющаяся.** (running) В Cortex-M3 имеется только одно ядро, соответственно, в данном состоянии в один момент времени может находиться только один поток.
- **Не выполняющиеся.** (not running) Во FreeRTOS все выполняющиеся задачи имеют три подсостояния.
1. **Готовая к выполнению.** (ready) Задачи в данном состояния ждут своей очереди на выполнение, т.е. они не заблокированы и не подвешены
2. **Заблокированная.** (blocked) Задача, находящаяся в заблокированном состо янии, ожидает либо временного (истечение заданной задержки), либо внешнего события (например, нажатие кнопки). Если две задачи хотят работать с одним блоком памяти (или периферией), то, очевидно, пока одна задача не завершит работу, другая не должна вмешиваться и производить какие-либо действия.
3. **Подвешенный.** (suspended) Данное состояние похоже на заблокированное, с тем отличием, что временного ограничения у нее нет, вход и выход из этого состояния осуществляются вызовом соответствующих функций.
![[Снимок экрана 2025-04-15 122840.png]]
Ядро ОС по некоторому внутреннему правилу дает выполняться одной из задач в один момент времени. Таким образом, система становится многозадачной (англ. multitasking).
##### Приоритет задачи
Каждой задаче присваивается приоритет - целое число, принадлежащее множеству [0, N]. Чем выше приоритет (0 - наивысший приоритет), тем важнее участок кода, т.е. его следует выполнить в первую очередь. Из всех задач формируется список, который сортируется по приоритету.
Список задач не может быть пустым, поэтому ОС создает так называемую задачу idle (простоя).
**Все задачи следует писать таким образом, чтобы они являлись реакцией на событие (event-driven).**
Приоритеты могут быть либо все фиксированные, либо все динамические, либо смешанные.
#### Планировщик
Планировщик (schedule) - сущность отвечающая за переключение задач. FreeRTOS поддерживает три алгоритма планировщика: вытесняющий (premptive) с квантовым времени (time slicing) и без, а также кооперативный (cooperative).
##### Вытесняющий алгоритм с квантованием времени
Как только появляется задача с более высоким приоритетом, операционная система переключается на нее, т.е. «вытесняет» менее приоритетную задачу. Для задач с одинаковым приоритетом системные ресурсы распределяются при помощи квантования времени.
Возьмем три задачи с разным приоритетом: idle, task_01 и task_02. Задача idle име ет наименьший приоритет, поэтому ее выполнение происходит только в то время, ко гда никакой другой задаче не нужны системные ресурсы. Задача task_02 имеет средний приоритет (выше, чем у idle) и большую часть времени находится в заблокированном состоянии (в ожидании некоторого события). task_01 аналогична task_02, но имеет более высокий приоритет.
![[Снимок экрана 2025-04-15 143921.png]]
А если задачам idle и taks_02 назначить одинаковые приоритеты? Планировщик будет переключаться между этими задачами по очереди. Допустим, в момент исполнения idle происходит событие, вызывающее task_01, и оно, выполнив свою работу, до наступления прерывания от системного таймера передает управление планировщику. Тот, для того чтобы равномерно распорядиться системными ресурсами, не даст продолжить работу idle, а переключится на task_02.
![[Снимок экрана 2025-04-15 144011.png]]
##### Вытесняющий алгоритм без квантования времени
Вытесняющий алгоритм без квантования работает схожим образом, но имеет один недостаток. Разница между временем работы задач с одинаковым приоритетом может отличаться в разы. Таким образом, квантование по времени, вводя накладные расходы позволяет уйти от ситуаций, когда одна из задач практически не будет исполняться.
![[Снимок экрана 2025-04-15 145127.png]]
##### Кооперативный алгоритм
В описанных выше алгоритмах принятие решения о запуске задачи полностью лежало на планировщике. Другой подход, называемый кооперативным (англ. co-operative), заключается в добровольной передаче управления. Т.е. пока выполняемая задача сама себя не заблокирует или не подвесит, никакая другая задача выполняться не сможет. Другими словами, переключение происходит только с позволения (англ. yield) текущей задачи.
![[Снимок экрана 2025-04-15 150345.png]]
##### Взаимодействие потоков
Любая ОСРВ предоставляет стандартные механизмы взаимодействия, такие как семафоры, мьютексы, очередь сообщений. 
Очереди - это про защиту памяти, они позволяют организовать безопасную передачу данных;
Семафоры - это про упорядочивание какого-то распределенного процесса, его синхронизацию;
Мьютексы - это про защиту аппаратных средств, т.е. обеспечение эксклюзивного доступа к ним.
##### Очередь сообщения
Очередь - массив однотипных (одноразмерных) данных с особым способом записи и чтения из него, называемым FIFO (First In, First Out). Размер очереди называется длиной, запись осуществляется в конец, он же "хвост", а чтение из начала, оно же "голова".
![[Снимок экрана 2025-04-16 115333.png]]
![[Снимок экрана 2025-04-16 115436.png]]
![[Снимок экрана 2025-04-16 115459.png]]
![[Снимок экрана 2025-04-16 115522.png]]
##### Семафоры
Семафоры позволяют удобнее работать с критическими секциями. Критическая секция - переменная или функция, доступ к которой должен быть только у одного потока. И в случае обращения к данному элементу из двух потоков одновременно может привести к сбою или не правильной работе программы.
##### Мьютексы
Мьютекс - разновидность семафора. Он служит для синхронизации одновременно выполняющихся задач и отличается тем, что только владеющий им поток может его освободить.
Семафорами можно заменить мьютексы, но не наоборот.
### FreeRTOS
FreeRTOS является одним из представителей ОСРВ.
Если рассмотреть типичное приложение с использованием FreeRTOS, то можно выделить три слоя поверх железа: пользовательский код, платформонезависимый код и платформозависимый код.
![[Снимок экрана 2025-04-22 170431.png]]
ПлатформоНЕзависимый код можно разделить на две под части: задачи и связь:
- Основное назначение ядра - создание, уничтожение и управление задачами. За это отвечают два файла: task.c и task.h
- Сами задачи так или иначе обмениваются данными. За связь между задачами отвечают файлы: queue.c и queue.h, а критические ресурсы работают через семафоры и мьютексы (semaphr.c и semaphr.h).
##### Установка и настройка
