#### Определение классов
Кроме использования встроенных типов, таких как int, double и т.д., мы можем определять свои собственные типы и классы. Класс представляет составной тип, который может использовать другие типы.
Класс предназначен для описания некоторого типа объектов. То есть по сути класс является планом объекта. Для определения класса применяется ключевое слово **class**:
```C++
class имя_класса
{
	//компоненты класса
};
```
Как правило, название классов начинаются с большой буквы. Допустим у нас есть класс, чьи данные представляют человека:
```C++
#include <iostream>

class Person
{
public:
	std::string name;
	unsigned age;
	void print()
		std::cout << "Name: " << name << "\nAge: " << age << std::endl;
};

int main()
{
	Person human;
	//устанавливаем значение полей касса
	human.name = "Tom";
	human.age = 38;
	//вызываем функцию класса
	human.print();
}
```
Переменные класса называются **полями класса**.
Также поля класса можно инициализировать некоторыми значениями:
```C++
...
class Person
{
public:
	std::string name{"Undefined"};
	unsigned age = 18;
	...
};
...
```
#### Конструкторы и инициализация объектов
Конструктор - специальная функция, которая имеет то же имя, что и класс, которая не возвращает никакого значения и позволяет инициализировать объект класса во время его создания.
Если не объявить явно конструктор, то компилятор автоматически собирает проект с конструктором по умолчанию.
```C++
...
class Person
{
public:
	std::string name;
	unsigned age;
	void print()
		std::cout << "Name: " << name << "\nAge: " << age << std::endl;
	Person(std::string p_name, unsigned p_age)
	{
		name = p_name;
		age = p_age;
		std::cout << "Person has been created" << std::endl;
	}
};

int main()
{
	Person tom("Tom", 38);
	tom.print();
}
```
##### Определение нескольких конструкторов
Есть возможность определять несколько конструкторов и затем их использовать:
```C++
...
	Person(std::string p_name, unsigned p_age)
	{
		name = p_name;
		age = p_age;
	}
	Person(std::string p_name)
	{
		name = p_name;
		age = 18;
	}
	Person()
	{
		name = "Undefined";
		age = 18;
	}
...
```
 Но такая запись достаточно громоздкая. И в C++ можно сократить их определения:
 ```C++
...
	Person(std::string p_name, unsigned p_age)
	{
		name = p_name;
		age = p_age;
	}
	Person(std::string p_name):Person(p_name, 18){}
	Person():Person(std::string("Undifined")){}
...
```
Подобная запись означает, что один конструктор делегирует действия по инициализации переменных первому конструктору. Данная техника называется **делегирование конструктора**.
Также конструкторам можно задать параметры по умолчанию. Если пользователь не введет никакие значения в конструктор класса, то он автоматически инициализирует переменные:
```C++
...
	Person(std::string p_name = "Undefined", unsigned p_age = 18)
	{
		name = p_name;
		age = p_age;
	}
...
```
##### Инициализация констант и списки инициализации
Классы с объявлением констант требуют особого отношения. В случае следующего примера, компилятор не сможет собрать проект. потому что константа не инициализирована.
```C++
class Person
{
	const std::string name;
	unsigned age{};
public:
	void print()
		std::cout << "Name: " << name << "\nAge: " << age << std::endl;
	Person(std::string p_name, unsigned p_age)
	{
		name = p_name;
		age = p_age;
	}
};
```
Для исправления ошибки необходимо использовать **списки инициализации**. Списки инициализации представляют перечисление инициализаторов для каждой из переменных через двоеточие после списка параметров конструктора:
```C++
class Person
{
	const std::string name;
	unsigned age{};
public:
	void print()
		std::cout << "Name: " << name << "\nAge: " << age << std::endl;
	Person(std::string p_name, unsigned p_age) : name{p_name}
	{
		name = p_name;
		age = p_age;
	}
};
```
Списки инициализации подобным образом можно использовать и для присвоения значений переменным:
```C++
class Person
{
	const std::string name;
	unsigned age{};
public:
	void print()
		std::cout << "Name: " << name << "\nAge: " << age << std::endl;
	Person(std::string p_name, unsigned p_age) : name{p_name}, age(p_age) {}
};
```
При использовании списков инициализации важно учитывать, что передача значений должна идти в том порядке, в котором константы и переменные определены в классе. То есть в данном случае в классе сначала определена константа name, а потом переменная age. Соответственно в таком же порядке идет передача им значений. Поэтому при добавлении дополнительных полей или изменения порядка существующих придется следить, чтобы все инициализировалось в надлежащем порядке.
##### Конструктор копирования
По умолчанию компилятор при компиляции классов генерируется специальный конструктор - **конструктор копирования**, который позволяет создать объект на основе другого объекта.
```C++
class Person
{
	...
};

int main()
{
	Person tom{"Tom", 38};
	Person tomas{tom};
}
```
В данном случае строка (Person tomas{tom};) представляет вызов конструктора копирования. 
Конструктор копирования - удобная вещь, когда необходимо создать один объект на основе другого, однако данный конструктор имеет свои недостатки. Если поле представляет указатель, то копируется адрес и тогда поля обоих объектов будут указывать на один и тот же адрес в памяти.
Конструктор копирования должен принимать в качестве параметра объект того же класса. Лучше параметр принимать по ссылке, потому что при передаче по значению компилятор будет создавать копию объекта. А для создания копия объекта будет вызывать конструктор копирования, что приведет к бесконечной рекурсии.
```C++
class Person
{
...
	Person(const Person &p)
	{
		name = p.name;
		age = p.age;
	}
};
```
Если конструктор копирования не нужен, то его необходимо удалить с помощью оператора **delete**:
```C++
class Person
{
...
	Person(const Person &p) = delete;
...
}
```
#### Управление доступом. Инкапсуляция
Не желательно, чтобы к некоторым компонентам класса был прямой доступ извне. Для разграничения доступа к различным компонентам класса применяются **спецификаторы доступа**. 
Спецификатор **public** делает члены класса - поля и функции открытыми, доступными из любой части программы.
Спецификатор **private** делает члены класса закрытыми, инкапсулировать внутри класса.
Если для каких-то компонентов отсутствует спецификатор доступа, то по умолчанию применяется спецификатор private.
**Инкапсуляция** - принцип, согласно которому внутреннее устройство сущностей нужно объединить в специальной "оболочке" и скрывать от вмешательства извне. Доступ к полям класса возможен через специальные открытые методы, а напрямую к ним обратиться нельзя.
#### Объявление и определение функций класса
В языке С++ можно разделить объявление и определение функций в том числе функции, которые создаются в классах.
```C++
class Person
{
private:
	std::string name;
	unsigned age;
public:
	Person(std::string p_name, unsigned p_age)
	{
		name = p_name;
		age = p_age;
	}
	void print()
		std::cout << "Name: " << name << "\nAge: " << age << std::endl;
};
```
Реализация методов вне класса:
```C++
class Person
{
private:
	std::string name;
	unsigned age;
public:
	Person(std::string p_name, unsigned p_age)
	void print()
};

Person::Person(std::string p_name, unsigned p_age)
{
	name = p_name;
	age = p_age;
}
void Person::print()
	std::cout << "Name: " << name << "\nAge: " << age << std::endl;
```
#### Константные объекты и функции
