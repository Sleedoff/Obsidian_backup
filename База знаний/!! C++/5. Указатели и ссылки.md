#### Ссылки
Ссылка - альтернативное имя для объекта. Для определения ссылки применяется знак амперсанда **&**:
```C++
int num 5;
int &refNum num;
```
После установления ссылки мы можем через нее манипулировать самим объектом, на который она ссылается. Изменения по ссылке неизбежно скажутся и на том объекте на который ссылается ссылка.
```C++
int main()
{
	int num = 5;
	int &refNum = num;
	std::cout << refNum << std::endl; // 5
	refNum = 20;
	std::cout << refNum << std::endl; // 20
}
```
Можно определить не только ссылки на переменные, но и на константы, но  при этом сама ссылка должна быть константой:
```C++
const int num = 5;
const int &refNum = num;
```
Также константная ссылка может указывать и на обычную переменную, только значение по этой ссылке мы не сможем изменить.
```C++
int num = 5;
const int &refNum = num;
std::cout << refNum << std::endl; // 5
//мы можем изменить саму переменную
num = 20
std::cout << refNum << std::endl; // 20
```
#### Указатели
Указатели - объекты, значением которых служат адреса других объектов или функций. Для объявления указателя, необходимо указать тип данных, на который будет указывать указатель, после чего идет знак звёздочки и далее названием указателя. 
```C++
int* ptr;
```
Для присвоения указателю переменной, адрес которой он будет хранить необходимо использовать операцию &. Выражение **&num** возвращает адрес переменной num. 
```C++
int num = 5;
int* ptr = &num;
```
Для получения значения переменной, хранящейся по данному адресу применяется операция разыменования.  Результатом этой операции всегда является объект, на который указывает указатель.
```C++
#include <iostream>

int main()
{
    int number {25};
    int *pnumber {&number};
    std::cout <<"Address = "<< pnumber<< std::endl;
    std::cout <<"Value = "<< *pnumber << std::endl;
}
```
Мы также можем присваивать указателю другой указатель. Когда указателю присваивается другой указатель, то фактически первый указатель начинает также указывать на тот же адрес, на который указывает второй указатель:
```C++
#include <iostream>

int main()
{
	int a = 10;
	int b = 2;
	int *pa = &a;
	int *pb = &b;
	std::cout <<"pa: address="<< pa <<"\t value="<< *pa << std::endl;
	std::cout <<"pb: address="<< pb <<"\t value="<< *pb << std::endl;

	pa = pb;

	std::cout <<"pa: address="<< pa <<"\t value="<< *pa << std::endl;
	*pa = 125;
	std::cout <<"b value="<< b << std::endl;
}
```
Если мы не хотим, чтобы указатель указывал на какой-то конкретный адрес, то можно присвоить ему условное нулевое значение. Для определения нулевого указателя можно инициализировать указатель нулем или константой **nullptr**. 
```C++
int *p1{nullptr};
int *p2{};
```
Константный указатель - особый тип указателя, у них нельзя изменять адрес, который в них хранится, но можно изменять значение по этому адресу:
```C++
int main()
{
	int a = 10;
	int *const pa = &a;
	std::cout << "value= " << *pa << std::endl; // value = 10
	*pa = 22;
	std::cout << "value= " << *pa << std::endl; // value = 22
}
```
###### Ссылки на указатели
Так как ссылка не является объектом, то нельзя определить указатель на ссылку, однако можно определить ссылку на указатель. Через подобную ссылку можно изменять значение, на которое указывает указатель или изменять адрес самого указателя:
```C++
#include <iostream>

int main()
{
	int a = 10;
	int b = 6;

	int *p{};      // указатель
	int *&pRef = p; //ссылка на указатель
	pRef = &a;     //через ссылку указателю присваивается адрес переменной
	std::cout << "p value= " << *p << std::endl; // 10
	*pRef = 70;    // изменяем значение по адресу
	std::cout << "a value= " << a << std::endl; // 70
	pRef = &b;     // изеняем адрес, на который указывает указатель
	std::cout << "p value= " << *p << std::endl; // 6
}
```
##### Массив указателей
Массив указателей - массив, который содержит в себе указатели. Зачастую применяется для работы с массивами строк.
```C++
#include <iostream>
using namespace std;

int main()
{
	char* err[] = {"Cannot open file\n", "Read Error\n", "Write error\n", "Media Failure\n"};
	int num;
	cout << "Write a num of error: ";
	cin >> num;
	if(num>=0 && num<4)
		cout << "Error - " << err[num];
	else
		cout << "Wrong number!\n";
}
```
В данном примере мы обращаемся к указателю первой буквы строки. Так работает потоковый вывод. 
Также, при сортировке удобнее работать с массивом указателей, так как мы будем менять не строки местами, а переопределять указатели.
![[Снимок экрана 2025-05-12 120343.png]]
```C++
#include <iostream>
using namespace std;

define N 5

int main()
{
	char s[N][20], *ptr[N];
	cout << " Write " << N << " strings:\n";
	for(int i=0; i<N; i++)
	{
		cin >> s[i];
		ptr[i] = s[i];
	}
	for(int k=N-1; k>0; k--)//первая граница сортируемой области уменьшается
	{
		for(int i=0; i<k; i++) //i - индекс первого элемента из пары
		{
			if(*ptr[i] < *ptr[i+1]) //сравнение букв слов
			{
				char *tmp = ptr[i]; //перестановка указателей
				ptr[i] = ptr[i+1];
				ptr[i+1] = tmp;
			}
		}
	}
	//вывод новой строки
}
```
##### Различия указателя от ссылки
- Нельзя объявить массив ссылок
- У ссылки нет адреса
- Существует арифметика указателей, но нет арифметики ссылок
- Указатель может иметь "невалидное" значение с которым его можно сравнить перед использованием
- Ссылка не может быть неинициализированной
- Ссылка не может быть изменена после инициализации
- Ссылки всегда разыменовываются автоматически
- Ссылки инициализируются не адресом, а самим объектом
#### Smart-указатели
Smart pointers или "интеллектуальные указатели" - объекты, которые имитируют стандартные указатели, но главное их отличие от стандартных указателей состоит в том, что нам не надо беспокоиться об освобождении памяти с помощью операторов delete и delete[].
##### unique_ptr<>
Указатель unique_ptr<> представляет указатель на тип T, который является "уникальным" в том смысле, что что может быть только один объект unique_ptr, который содержит один и тот же адрес. То есть не может одновременно быть двух или более объектов unique_ptr<>, которые указывают один и тот же адрес памяти. Если же мы попробуем определить два одновременно существующих указателя, которые указывают на один и тот же адрес, компилятор не скопирует код.
И когда unique_ptr уничтожается, уничтожается и значение, на которое он указывает. Соответственно данный тип указателей полезен, когда нужен указатель на объект, на который НЕ будет других указателей и который будет удален после удаления указателя.
```C++
std::unique_ptr<int> ptr;
//аналогичные объявления
std::unique_ptr<int> ptr{};
std::unique_ptr<int> ptr{nullptr};
```
