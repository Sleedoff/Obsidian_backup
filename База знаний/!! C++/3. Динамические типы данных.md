##### Односвязный список
Односвязный список - совокупность элементов, каждый из которых имеет два "параметра": адрес следующего элемента и значение, которое хранится в текущем элементе. У последнего элемента в параметре адрес будет значение null.
Для получения данных из односвязного списка необходимо перебирать все элементы по порядку. А если нам нужен какой-то определенный элемент, то ещё необходим счётчик, благодаря которому мы поймём, что это третий элемент списка.
Односвязный списки имеют преимущество по быстродействию в случае динамического добавления элементов. И недостаток в случае доступа к определенным элементам списка.
![[23a3d44a885165eaecf080780931c5ca.png]]
##### Двусвязный список
Двусвязный список - совокупность элементов, каждый из которых имеет три "параметра": адрес следующего элемента, адрес предыдущего элемента и значение, которое хранится в текущем элементе.
![[image003.jpg]]
##### Бинарное дерево
Бинарное дерево состоит из элементов "узлов", Каждый из узлов является родителем для двух других узлов. В свою очередь эти узы являются для первоначального узла потомками. Самый первый элемент, у которого нет родителя, является корнем дерева.
![[image002.png]]
Добавление элементов в правую и левую часть является упорядоченным. Тоесть в зависимости от значения данные помещаются либо в правую, либо в левую часть.
![[image003.png]]
##### Стек
Стек - тип динамической памяти, основанный на логике односвязного списка, которая подчиняется принципу последний зашел - первый вышел.
![[unnamed.png]]
##### Простая очередь
Простая очередь - тип динамической памяти, которая работает по тому же принципу, что и обычная очередь: первый пришел - первый вышел.
Мы можем взаимодействовать с очередью, через её первый или последний элемент. Мы не можем добавить элемент в начало очереди. Извлечь данные мы можем только с первого элемента, но не из середины или конца очереди.
##### Кольцевая очередь
Суть у кольцевой очереди такая же как и у простой очереди. За единственным исключением, что когда мы извлекаем данные из первого элемента, мы его помещаем в конец очереди.
##### Очередь с приоритетом
Элементы помещаются в очередь в том порядке, в каком они поступили, но извлекаются из неё по приоритетности. Но также есть вариант, когда мы сначала сортируем данные по приоритетности и только после извлекаем их.
Тоесть внутри очереди есть своя очередь по приоритетам. 
##### Дек (DEQUE)
Дек - двусторонняя очередь. С каждой из сторон мы можем как добавить, так и взять данные.
Бывают дэк с ограниченным входом, либо дэк с ограниченный выходом - когда с одного из выходов отсутствует система добавления или принятия данных.
Работая с дэком, мы можем работать со всеми элементами, находящимися в очереди.
Дек работает по логике двусвязного списка, состоящего из небольших массивов, при заполнении одного из которых создается где-то новый, имеющий ссылки на следующий и предыдущие массивы, и уже новый массив заполняется.
##### Динамические объекты
В C++ можно использовать различные типы объектов, которые различаются по использованию памяти. Так, глобальные объекты создаются при запуске программы и освобождаются при ее завершении. Локальные автоматические объекты создаются в блоке кода и удаляются, когда этот блок кода завершает работу. Локальные статические объекты создаются перед их первым использованием и освобождаются при завершении программы.
Глобальные, а также статические локальные объекты помещаются в статической памяти, а локальные автоматические объекты размещаются в стеке. Объекты в статической памяти и стеке создаются и удаляются компилятором. Статическая память очищается при завершении программы, а объекты из стека существуют, пока выполняется блок, в котором они определены. Когда блок завершает выполнение, то память в стеке, отведенная для переменных блока, освобождается.
В дополнение к этим типам в C++ можно создавать динамические объекты. Продолжительность их жизни не зависит от того, где они созданы. Динамические объекты существуют, пока не будут удалены явным образом, эти объекты размещаются в динамической памяти (free store).
###### Выделение памяти
Создание динамического объекта:
```C++
int *ptr = new int;
```
Оператор **new** создает новый объект типа int в динамической памяти и возвращает указатель на него. Таким образом, указатель ptr содержит адрес выделенной памяти. Значение такого объекта не определено. 
В выше описанном случае указатель ptr получает значение по умолчанию - число 0. Для инициализации можно использовать один из ниже приведенных вариантов:
```C++
int *ptr{new int{5}};
// альтернативные варианты
// int *ptr = new int{5};
//int *ptr {new int(5)};
//int *ptr = new int(5);
```
###### Освобождение памяти
Динамические объекты будут существовать, пока не будут явным образом удалены. Для освобождения памяти используется оператор **delete**:
```C++
int *ptr{new int{5}};
//действия с переменной
delete ptr;
```
Если явным образом не вызвать оператор delete, то выделенная динамическая память будет освобождена после завершения программы.
Даже после освобождения памяти указатель по прежнему содержит старый адрес, хотя память по нему условно освобождена и готова к использованию для будущих динамических объектов. Такой указатель называется "болтающимся указателем" (dangling pointer). Для избавления от таких болтающихся указателей, необходимо обнулить указатель.
```C++
int *ptr{new int{5}};
//действия с переменной
delete ptr;
ptr = nullptr; //обнуляем указатель
```
###### Динамические массивы
Для выделения памяти под динамический массив также используется оператор new, после которого в квадратных скобках указывается, сколько массив будет содержать объектов:
```C++
int *numbers1 {new int[4]};
//аналогичные определения массивов
/*
int *numbers {new int[4]{}};
int *numbers {new int[4]{1, 2, 3, 4}};
int *numbers = new int[4]{};
int *numbers = new int[4]{1, 2, 3, 4};
*/
```
Для доступа к элементам динамического массива можно использовать как синтаксис массивов (numbers[0]), так и операцию разыменования (****numbers)***.
Для удаления динамического массива и освобождения его памяти применяется специальная форма оператора delete:
```C++
int* p{new int[5]{1, 2, 3, 4, 5}};
//работа с массивом
delete [] p;
p=nullptr;
```
###### Многомерные массивы
Есть возможность создавать многомерные динамические массивы. Чтобы создать общий динамический двухмерный массив, нам надо создать общий динамический массив указателей, а затем его элементы - вложенные динамические массивы:
```C++
#include <iostream>

#define C 2
#define R 3

int main()
{
	int** numbers = new int*[R]{};
	for(int i=0; i<R; i++)
		numbers[i] = new int[C]{};
	// работа с данными
	for(int i=0; i<R; i++)
		delete[] numbers[i];
	delete[] numbers;
}
```


